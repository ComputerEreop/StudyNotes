#### java内存区域
* 方法区: 用户存储已经被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等。异常状态有异常状态有OutOfMemoryError
* 常量池: 运行时常量池一般存放在方法区中，用户用于存放编译器生成的各种字面量和符号引用
* 堆内存: 是jvm所管理的内存中最大的一块，唯一的目的就是存放实例对象，几乎所有的实例对象都存放在这里.java堆是垃圾收集器管理的主要区域，异常状态内存溢出
* 虚拟机栈: 描述的是方法执行的内存模型，每个方法在执行的时候都会创建一个栈帧，用户存储局部变量表，操作数栈，动态链接，方法出口等信息
* 本地方法栈：和虚拟机栈发挥的作用相同，但是本地方法执行的是native方法服务
* 程序计数器：一块较小的内存，当前线程所执行的字节码的行号指示器。字节码执行工作的时候就是通过改变这个计数器的值来选取下一个需要执行的字节码指令

#### java内存模型
##### java内存模型的目的
屏蔽掉各种硬件和操作系统的内存访问差异，用来实现让java程序在各种平台下都能达到一直的内存访问效果
java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作线程。线程的工作线程阿訇保存了该线程所有用到的变量，这些变量都是从主内存中读取来的。线程对变量的所有操作都是在工作线程中进行的，不同线程之间也无法执行访问对方线程的变量。
#### 八种操作
* lock 作用于主内存的变量，把一个变量标识为一个线程的独霸状态
* unlock 作用于主内存的变量，把一个处于锁定状态的变量释放出来
* read把一个变量的值从主内存传递到工作内存中去，
* load 把read的到的变量放到工作线程的工作副本中去
* use 把工作线程中一个变量的值传递给执行引擎
* assign 把一个从执行引擎得到的值传递给工作内存
* store 把工作线程中的一个变量传递给主内存
* write 把store工作中得到的值放到主内存的变量中

#### http 请求和响应步骤
* 1，建立TCP连接
* 2，web浏览器向web服务器发送请求命令
* 3，web浏览器发送请求头信息
* 4，web浏览器应答
* 5，web浏览器发送应答头信息
* 6，web服务器向浏览器发送数据
* 7，web服务器关闭tcp连接，一旦服务器向服务器发送了数据，就会关闭tcp。如果添加connection：keepAlive。tcp在连接发送后仍然保持打开状态

#### http 请求报文
* 1，请求行：请求方法，URL，协议版本；请求方法主要有GET，POST。URL=协议+主机+路径+参数
* 2，请求头：请求头部为请求报文添加了一些附加信息，常见的请求头Host，接受请求的服务器地址，USER-Agent发送请求的应用程序名称
* 3：请求数据：可选部分，get没有请求数据
#### http 请求报文
* 1，状态行：协议版本，状态码，状态码描述（状态码 200响应成功,302跳转，跳转的地址通过响应头的location制定,400客户端请求有语法错误,403服务器收到请求但是不想赢,404访问资源不存在,500服务器内部错）
* 2，响应头部
* 3，响应正文用于存放需要返回给客户端的数据
#### https 简介
https其实有两部分组成 http + ssl + tls也就是在http上面加了一层处理加密信息的模块。服务端和客户端的传输都会通过tls进行加密，所以传输的数据都是加密后的数据

